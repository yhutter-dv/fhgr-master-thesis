\chapter{Diskussion}
\label{chap_diskussion}
Dieses Kapitel fasst die zentralen Aspekte und Erkenntnisse der Arbeit zusammen und diskutiert diese anhand der in Kapitel \ref{chap_einleitung} definierten Forschungsfragen. Ziel ist es, die Ergebnisse kritisch zu reflektieren und die im Verlauf der Arbeit getroffenen Entscheidungen nachvollziehbar einzuordnen.

\section{Wahl der Technologie}
Für die Entwicklung einer echtzeitfähigen 3D-Datenvisualisierung ist die Wahl der zugrunde liegenden Technologie von zentraler Bedeutung. Zur Beantwortung der Forschungsfrage \textbf{F1} (``Welche Technologie ist für eine echtzeitfähige 3D Datenvisualisierung geeignet?'') lag der Fokus dieser Arbeit auf Spiele-Engines und Frameworks. Ein wesentlicher Vorteil von Engines gegenüber Frameworks besteht darin, dass sie integrierte Editoren zur Erstellung von 3D-Visualisierungen bereitstellen. Ebenso bieten sie in der Regel ein umfangreicheres Funktionsspektrum sowie eine breitere Plattformunterstützung.

Andererseits bringen proprietäre Engines wie Unity oder Unreal auch Einschränkungen mit sich. Abhängig vom jeweiligen Lizenzmodell können zusätzliche Kosten entstehen, und bei technischen Problemen ist man auf den Support der Hersteller angewiesen. Zudem ist der Quellcode nicht frei zugänglich, wodurch Anpassungen oder Fehlerbehebungen nur eingeschränkt möglich sind. Je nach Engine sind darüber hinaus ein erheblicher Einarbeitungsaufwand sowie der Erwerb leistungsfähiger Hardware erforderlich.

Frameworks sind aufgrund ihres reduzierten Funktionsumfangs platzsparender und ressourcenschonender als vollwertige Spiele-Engines. Sie stellen zentrale Funktionalitäten in Form wiederverwendbarer Module bereit, deren Zusammenspiel zu einer funktionierenden Gesamtlösung in der Verantwortung der Nutzer liegt. Abhängig vom Anwendungsfall, der Komplexität und dem fachlichen Hintergrund können Frameworks daher besser geeignet sein als umfangreiche und komplexe Engines. Zentrale Voraussetzungen für den erfolgreichen Einsatz eines Frameworks sind eine gute Dokumentation sowie aussagekräftige Anwendungsbeispiele. Im Verlauf dieser Arbeit hat sich gezeigt, dass Three.js eine geeignete Wahl für die Umsetzung der Terrainvisualisierung darstellt. Zwar mussten zahlreiche Komponenten eigenständig implementiert werden, dadurch konnte jedoch eine Lösung entwickelt werden, die gezielt auf die vorliegende Problemstellung zugeschnitten ist. Bei auftretenden Schwierigkeiten erwiesen sich die umfangreiche Dokumentation, eine aktive Community sowie zahlreiche Praxisbeispiele als wertvolle Unterstützung.

\section{Wahl des Algorithmus}
Um die Echtzeitfähigkeit einer Terrainvisualisierung sicherzustellen, ist die Wahl des korrekten Algorithmus ein wichtiger Faktor. Zur Beantwortung der Forschungsfrage \textbf{F2} (``Welche Algorithmen eignen sich für die Darstellung von Gebirgslandschaften in Echtzeit?'') wurden verschiedene Algorithmen wie Geometry Clipmaps, Quadtree sowie \acrfull{CDLOD} evaluiert. Die Entscheidung den Quadtree-Algorithmus einzusetzen, basiert hierbei auf mehreren technischen und konzeptionellen Überlegungen. Quadtrees eignen sich besonders gut für die hierarchische Unterteilung von Regionen und werden daher häufig in der Terrain- und Geodatenvisualisierung eingesetzt. Da die zugrunde liegenden swisstopo-Datensätze bereits in regelmässige, kachelbasierte Strukturen unterteilt sind, lässt sich diese Datenorganisation unmittelbar auf einen Quadtree abbilden. Ein weiterer zentraler Vorteil des Quadtree-Ansatzes liegt in der einfachen und effizienten Umsetzung eines Level-of-Detail-Systems. Durch die rekursive Unterteilung des Terrains kann die Detailstufe dynamisch an die aktuelle Kameraposition angepasst werden, sodass nahe Bereiche hochaufgelöst und weiter entfernte Regionen vereinfacht dargestellt werden. Darüber hinaus zeichnet sich der Quadtree-Algorithmus durch eine vergleichsweise geringe Implementierungskomplexität aus. Im Vergleich zu alternativen Verfahren wie Geometry Clipmaps oder \acrfull{CDLOD} ist der Quadtree konzeptionell leichter verständlich und gut in bestehende Frameworks wie Three.js integrierbar. Zusammenfassend wurde der Quadtree-Algorithmus gewählt, da er eine gute Balance zwischen Leistungsfähigkeit, Flexibilität und Implementierungsaufwand bietet. Er erlaubt eine effiziente Verwaltung grosser Terrainflächen, lässt sich gut mit kachelbasierten Geodaten kombinieren und bildet eine stabile Grundlage für weiterführende Optimierungen und Erweiterungen.

\section{Datenvorverarbeitung}
Ähnlich wie beim Bau eines Gebäudes ein stabiles Fundament die Grundlage für alle weiteren Arbeitsschritte bildet, ist bei der Datenvisualisierung eine saubere und strukturierte Datenvorverarbeitung von zentraler Bedeutung. Um die Forschungsfrage \textbf{F3} (``Welche Problemstellungen treten bei der Datenvorverarbeitung auf?'') fundiert zu beantworten, werden im Folgenden die wesentlichen Verarbeitungsschritte sowie die daraus gewonnenen Erkenntnisse nochmals zusammengefasst und eingeordnet.

Als Datengrundlage dienten die beiden swisstopo-Datensätze swissALTI3D sowie swissIMAGE. Während swissALTI3D ein digitales Höhenmodell bereitstellt, enthält \\swissIMAGE die orthografisch korrigierten Luftbilder. Die Kombination beider Datensätze bildet die Grundlage für die Rekonstruktion der 3D-Modelle und damit die Datenbasis der Terrainvisualisierung.
Beide Datensätze liegen in Form von 1 km auf 1 km grossen Kacheln (Tiles) vor und sind in unterschiedlichen Auflösungen verfügbar. Die räumliche Referenzierung erfolgt dabei auf Basis des LV95-Koordinatensystems. Um die Komplexität der Datenvorverarbeitung zu reduzieren, wurde für beide Datensätze eine einheitliche Auflösung von 2 m pro Pixel verwendet.

Zu Beginn wurden die benötigten Informationen aus den Datensätzen extrahiert. Beim swissALTI3D-Datensatz erfolgte dies in Form von Graustufenbildern, bei denen die einzelnen Höhenwerte als Pixel gespeichert werden. Hohe Lagen werden hierbei durch helle, niedrige durch dunkle Farben repräsentiert.
Um ein zusammenhängendes Höhenmodell zu erhalten, wurden die einzelnen Tiles anschliessend anhand des LV95-Koordinatensystems zu einem Gesamtbild kombiniert. Dabei zeigte sich, dass eine Normalisierung der Höhenwerte erforderlich ist. Ohne diesen Schritt entstehen an den Kanten visuelle Diskrepanzen, da jede Kachel eigene minimale und maximale Höhenwerte besitzt und dadurch keine fliessenden Übergänge gewährleistet sind.

Die Geodaten können für unterschiedliche Regionen direkt über die Webseite von swisstopo bezogen werden. Der Download ist entweder einzeln oder gesammelt über CSV-Dateien möglich, welche die entsprechenden Download-Links enthalten. Um diesen Prozess zu vereinfachen, wurde der Downloadprozess mithilfe eines Python-Skripts automatisiert. Zu diesem Zweck werden die bereitgestellten CSV-Dateien eingelesen und die benötigten Daten heruntergeladen. Im Anschluss werden die einzelnen Tiles zu einem Gesamtbild zusammengesetzt. Dabei zeigte sich, dass das resultierende Bild vereinzelt schwarze Bereiche enthalten kann, die auf fehlende Datensätze zurückzuführen sind. Da die Datensätze jedoch auf dem LV95-Koordinatensystem basieren und die Download-URLs einer festen Struktur folgen, lassen sich diese Datenlücken erkennen und automatisiert schliessen. Abschliessend wird das Gesamtbild auf einen quadratischen Ausschnitt begrenzt, da Grafikkarten Texturen mit gleich langen Seiten effizienter verarbeiten können.

Anschliessend wurde das Gesamtbild in mehrere Tiles mit unterschiedlichen Auflösungsstufen (LOD) unterteilt. Jede dieser Auflösungsstufen entspricht dabei einer Node innerhalb der Quadtree-Datenstruktur. Bei der Erstellung der Tiles in verschiedenen Detailstufen trat jedoch ein weiteres Problem auf: Zwischen benachbarten Tiles existieren keine Übergangsbereiche. Dadurch entstehen an den Kanten sichtbare Risse.
Um diesen Effekt zu vermeiden, wurden an den Randbereichen eines Tiles zusätzlich die Höhenwerte der jeweils angrenzenden Nachbar-Tiles übernommen, sodass ein nahtloser Übergang zwischen den einzelnen Kacheln gewährleistet ist.

\section{Umsetzung der Visualisierung}
Die Umsetzung einer echtzeitfähigen Terrainvisualisierung ist mit verschiedenen Herausforderungen verbunden. Zur Beantwortung der Forschungsfrage \textbf{F4} (``Welche Probleme treten bei der 3D-Datenvisualisierung von Gebirgslandschaften auf?'') müssen mehrere Aspekte berücksichtigt werden. Zentrale Voraussetzungen sind dabei eine fundierte Datenvorverarbeitung sowie die Wahl eines geeigneten Algorithmus. In dieser Arbeit wurde ein Quadtree-Algorithmus eingesetzt, der eine effiziente Unterteilung grosser geografischer Gebiete erlaubt. Die Struktur des Quadtrees wird dabei fortlaufend anhand der aktuellen Kameraposition und der Distanz zu den einzelnen Nodes angepasst.

Auf Basis des Quadtrees und der vorverarbeiteten Daten werden die zugehörigen 3D-Modelle generiert. Als geometrische Grundlage kommt ein sternförmiges Gitternetz zum Einsatz. Die Vertices dieses Gitters werden im Vertex-Shader anhand der Höhendaten vertikal versetzt, wodurch die Geländeform entsteht. Die visuelle Ausgestaltung erfolgt im Fragment-Shader, in dem die orthografischen Luftbilder als Texturen auf die Geometrie projiziert werden.

Bei der Darstellung des Gebirges auf Basis der 3D-Modelle zeigte sich eine weitere Problematik: Treffen Geometrien mit unterschiedlicher Auflösung aufeinander, entstehen an den Kanten sichtbare Risse. Ursache hierfür ist, dass die Vertices entlang der gemeinsamen Kanten nicht exakt übereinstimmen und somit keine nahtlose Verbindung bilden. Zur Behebung dieses Effekts wurde das Index-Stitching-Verfahren eingesetzt. Damit dieses korrekt funktioniert, dürfen sich benachbarte Nodes im Quadtree höchstens um eine Baumtiefenstufe unterscheiden. Zu diesem Zweck wurde der Quadtree entsprechend ausbalanciert. Zur Validierung der Umsetzung wurden zusätzlich Hilfsvisualisierungen implementiert, mit denen sowohl die Quadtree-Struktur als auch das Index-Stitching-Verfahren validiert werden konnten.

\section{Ästhetik}
Neben der funktionalen Darstellung spielt auch die visuelle Ästhetik eine zentrale Rolle. Die Forschungsfrage \textbf{F5} (``Wie kann die Ästhethik einer 3D Terrainvisualisierung beeinflusst werden?'') umfasst dabei mehrere Facetten. Durch den Einsatz von HDR-Texturen konnte das Helligkeitsspektrum der Farben deutlich erweitert werden. In Kombination mit unterschiedlichen Tone Mapping-Verfahren liessen sich so verschiedene ästhetische Ausprägungen der Visualisierung erzeugen.

Bei der Navigation durch das Terrain können abhängig vom Betrachtungswinkel unscharfe Texturen in grösserer Entfernung auftreten. Zur Reduktion dieses Effekts wurde das Anisotropic Filtering von Three.js eingesetzt. Um zusätzlich den Eindruck einer realen Umgebung zu verstärken, wurde ein dynamischer Himmel mit Sonnenstand sowie einem Tag-Nacht-Zyklus integriert. Dabei konnte auf das umfangreiche Ökosystem von Three.js zurückgegriffen werden.

Damit die Auswirkungen der oben beschriebenen Verfahren in Echtzeit observiert werden können, wurden UI-Elemente (Tweaks) implementiert, mit denen sich die relevanten Parameter dynamisch anpassen lassen.

\section{Optimierungen}
Im Zentrum der Optimierung steht die Forschungsfrage \textbf{F6} (``Welche Optimierungen sind notwendig, um die Echtzeitfähigkeit der Visualisierung sicherzustellen?''). Zur Beantwortung dieser Frage wurde zunächst die Leistungsfähigkeit der Visualisierung untersucht. Die Messungen erfolgten anhand der Region Chur auf einem MacBook Pro M3 Max, das an einen Monitor mit einer Auflösung von 5120 × 2880 Pixeln angeschlossen war.
Mithilfe der Bibliothek stats-gl konnten zentrale Metriken wie Bildwiederholrate sowie CPU- und GPU-Auslastung in Echtzeit erfasst werden. Die Auswertung zeigte, dass die Terrainvisualisierung das definierte Ziel von mindestens 60 Bildern pro Sekunde erreicht.
Um dieses Leistungsniveau auch bei zunehmender Komplexität sicherzustellen, wurden mehrere Optimierungen umgesetzt. Da der Quadtree-Algorithmus periodisch ausgeführt wird und seine Rechenkomplexität mit der Grösse der dargestellten Region zunimmt, wurde dessen Berechnung mithilfe von Webworkern in einen separaten Thread ausgelagert und im Hintergrund ausgeführt. Um Ladeverzögerungen zu vermeiden, werden die benötigten Texturen zudem beim Start der Visualisierung vorgeladen.

Während der Bewegung durch das Gebirge konnten vereinzelt kurze Unterbrechungen verzeichnet werden. Mithilfe der integrierten Browser-Monitoring-Tools wurden dabei zwei Ursachen identifiziert. Eine davon war die Übersetzung von TSL nach GLSL bzw. WGSL. Diese Transpilation erfolgt auf der CPU und erwies sich als zeitintensiv. Die Lösung dieses Problems bestand darin, auf das robustere WebGL-Backend von Three.js zu wechseln und die Shader direkt in der nativen Sprache (GLSL) zu implementieren. Hiermit konnte der Übersetzungsschritt von TSL nach GLSL eliminiert werden. Eine weitere Problematik trat beim Dekodieren der Bilddateien auf. Damit die Bilder von der Grafikkarte entsprechend verarbeitet werden können, müssen diese zuerst dekodiert und von der CPU an die GPU gesendet werden. Dieser Dekodierungsschritt hat ebenfalls zu Verzögerungen geführt. Um das Dekodierungsproblem zu eliminieren, wurden die Bilder in das für Grafikkarten optimierte KTX2-Format umgewandelt. Dieses Format hat den Vorteil, dass die Bilder nicht dekodiert werden müssen und direkt an die Grafikkarte gesendet werden können. Mittels dieser Optimierungen konnten die Unterbrechungen beseitigt werden.