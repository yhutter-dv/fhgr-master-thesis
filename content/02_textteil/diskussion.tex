\chapter{Diskussion}
\label{chap_diskussion}
Dieses Kapitel fasst die wichtigsten Aspekte und Erkenntnisse zusammen und thematisiert diese anhand der in Kapitel \ref{chap_einleitung} definierten Forschungsfragen. Ziel ist es, eine konstruktive Diskussion zu führen, in welcher auch die Entscheidungen des Autors reflektiert werden.

\section{Wahl der Technologie}
Um eine echtzeitfähige 3D Datenvisualisierung zu erstellen, ist die Wahl der Technologie massgebend. Um die Frage \textbf{``Welche Technologie ist für eine echtzeitfähige 3D Datenvisualisierung geeignet?''}, zu beantworten, wurde der Fokus bei dieser Arbeit primär auf Spiele Engines sowie Frameworks gelegt. Ein Vorteil von Spiele Engines gegenüber Frameworks ist, dass Tools zur Erstellung von 3D Content in Form von Editoren zur Verfügung stehen. Zudem bieten Engines in der Regel ein breiteres Spektrum von Funktionalitäten und Plattformunterstützung an als Frameworks.

Jedoch müssen bei proprietären Engines wie Unity und Unreal entsprechende Lizenzgebühren, abhängig vom Einsatzzweck und Umsatz, entrichtet werden. Bei Problemen ist man auf entsprechenden Support des Herstellers angewiesen, eine Modifikation des Quellcodes gestaltet sich bei proprietären Engines schwierig. Bei Open Source Alternativen wie der Godot Engine nicht nur die Lizenzgebühren, eine Modifikation des Quellcodes ist bei schwerwiegenden Problemen ebenfalls möglich.

Engines bieten ein Komplettpaket zur Erstellung von 3D Inhalten an. Jedoch ist hierbei je nach Engine ein erheblicher Lernaufwand und entsprechende Hardware vonnöten. Anders als Engines bieten Frameworks kein Gesamtpaket, sondern einzelne Module an. Es ist dabei die Aufgabe des Programmierers, diese einzelnen Funktionalitäten zu einer funktionierenden Gesamtlösung zu vereinen. Frameworks sind ebenfalls um einiges platzsparender und ressourcenschonender als komplette Engines. Je nach Anwendungsfall, Wissensstand und Komplexität ist die dadurch gewonnene Freiheit eines Frameworks besser geeignet als eine Engine. Eine wichtige Voraussetzung hierbei ist jedoch eine gute Dokumentation und entsprechende Anwendungsbeispiele. Im Verlaufe dieser Arbeit hat sich für den Autor gezeigt, dass ein populäres Framework wie Three.js mit seiner entsprechend grossen Community, guter Dokumentation und vielen Anwendungsbeispielen die richtige Wahl für die Umsetzung der Terrainvisualisierung gewesen ist. Zwar mussten viele Aspekte selbst programmiert werden, jedoch konnte hierdurch auch eine auf die Problemstellung passende Lösung entwickelt werden.

\section{Datenvorverarbeitung}
Wie bei einem Hausbau zuerst das Fundament errichtet werden muss, ist bei der Datenvisualisierung, ob im zweidimensionalen oder dreidimensionalen Raum, eine solide Datenvorverarbeitung von entscheidender Bedeutung. Im Rahmen dieser Arbeit wurden Datensätze von swisstopo verwendet und in Form einer echtzeitfähigen, webbasierten 3D Terrainvisualisierung dargestellt. Um hierbei die Forschungsfrage \textbf{``Welche Probleme treten bei der Datenvorverarbeitung auf?''} adäquat zu beantworten, werden die wichtigsten Schritte und Erkenntnisse der Datenvorverarbeitung nochmals zusammengefasst und thematisiert.

Als Datengrundlage dienen die Datenquellen swissALTI3D und swissIMAGE. Der swissALTI3D Datensatz beinhaltet hierbei das digitale Höhenmodell, wohingegen der swissIMAGE Datensatz orthografisch korrigierte Luftbilder enthält. Die Kombination dieser beiden Datensätze bildet die Grundlage für die Erstellung der 3D-Geometrien und somit die Basis der Terrainvisualisierung. Beide Datensätze stellen jeweils 1km auf 1km grosse Kacheln (Tiles) basierend auf dem LV-95 Koordinatensystem zur Verfügung. Die Tiles stehen hierbei in unterschiedlichen Auflösungen zur Verfügung. Um die Komplexität zu reduzieren, hat sich der Autor dazu entschlossen, die gleiche Auflösung (2m pro Pixel) für beide Datensätze zu verwenden. 

Zu Beginn mussten die Daten extrahiert werden. Für den swissALTI3D Datensatz wurden die Höhenwerte hierbei als Graustufenbild gespeichert. Die einzelnen Höhenwerte werden als Pixel abgespeichert, wobei Weiss hohe und Schwarz niedrige Werte repräsentiert. Um ein Gesamtbild zu erhalten, sind anschliessend die einzelnen Tiles anhand des LV-95 Koordinatensystems zu einem Gesamtbild zusammengesetzt worden. Hierbei hat sich gezeigt, dass die Höhenwerte anhand eines globalen Minimums und Maximums normalisiert werden müssen, da sonst keine fliessenden Übergänge zwischen den einzelnen Tiles bestehen.

Grundsätzlich können die Daten von verschiedenen Regionen von der swisstopo-Webseite heruntergeladen werden. Die einzelnen Tiles dieser Regionen können entweder einzeln von Hand oder als eine CSV-Datei heruntergeladen werden. In der CSV-Datei sind die entsprechenden Downloadlinks zu den einzelnen Tiles hinterlegt. Der Autor hat sich hierbei entschlossen, den Downloadvorgang mithilfe eines Python-Skripts auf Basis von CSV-Dateien zu automatisieren. Beim Herunterladen und Zusammensetzen der einzelnen Tiles zu einem Gesamtbild wurde eine weitere Problematik festgestellt. Das zusammengesetzte Gesmatbild kann Lücken aufweisen, sprich, es fehlen Tiles. Der Grund hierfür ist, dass in den CSV-Dateien nicht alle notwendigen Tiles hinterlegt sind. Da jedoch die Tiles auf dem LV-95 Koordinatensystem basieren und die einzelnen URLs eine fixe Struktur aufweisen, konnten die fehlenden Tiles mithilfe des Python Preprocessing Scripts in der CSV-Datei hinterlegt und somit diese Lücken geschlossen werden.

Um die Daten optimal an die Quadtree-Struktur anzupassen, wurde das Gesamtbild anschliessend in mehrere Tiles mit unterschiedlichen Auflösungen (LOD-Level) aufgeteilt. Die einzelnen LOD-Level entsprechen hierbei den einzelnen Nodes innerhalb des Quadtrees. LOD 1 entspricht einer Baumtiefe von 1 und besitzt daher 4 ($2^2$) Kinder. LOD 2  entspricht einer Baumtiefe von 2 und besitzt 16 ($2^3$) Kinder etc. Da Grafikkarten Bilder in einer quadratischen Auflösung bevorzugen, wurde hierbei das Gesamtbild ebenfalls auf einen quadratischen Ausschnitt beschränkt. Das Unterteilen in einzelne LOD-Level ist zum einen die Grundlage für den Quadtree-Algorithmus, zum anderen wird hiermit auch sichergestellt, dass auch grosse Bilddateien effizient repräsentiert werden können. Beim Erstellen der einzelnen Tiles in unterschiedlichen Auflösungen offenbarte sich jedoch ein neues Problem. Zwischen den einzelnen Tiles besteht kein Übergang. Dies führte dazu, dass Risse zwischen den Bereichen entstanden. Um dieses Problem zu lösen, mussten jeweils die Höhenwerte der unmittelbaren Nachbarn mitkopiert werden. Ein Übergangsbereich von rund einem Pixel reicht hierbei aus, um die Lücken zu schliessen.

\section{Umsetzung der Visualisierung}
Die Umsetzung einer echtzeitfähigen Terrainvisualisierung ist mit entsprechenden Hürden verbunden. Um hierbei die Frage \textbf{``Welche Probleme treten bei der 3D Datenvisualisierung von Gebirgen auf?''} entsprechend zu beantworten, müssen verschiedene Aspekte thematisiert werden. Eine grundlegende Voraussetzung sind sowohl eine saubere Datenvorverarbeitung als auch die Wahl des korrekten Algorithmus. Der Autor hat sich hierbei für einen Quadtree basierten Algorithmus entschieden. Mithilfe des Quadtree war es möglich, grosse räumliche Gebiete auf eine effiziente Art und Weise zu unterteilen. Der Quadtree wird hierbei abhängig von der aktuellen Kameraposition sowie dem euklidischen Abstand zu den einzelnen Nodes erzeugt.

Anhand dieser Unterteilung und auf Basis der vorverarbeiteten Daten, sind anschliessend die entsprechenden 3D-Geometrien erstellt worden. Hierbei wird pro Node des Quadtrees eine 3D Geometrie erzeugt. Die geometrische Struktur ist hierbei ein sternförmiges Punktegitter, welches abhängig von der Baumtiefe (LOD Level) entsprechend grösser oder kleiner skaliert wird. Die einzelnen Punkte (Vertices) des Gitters werden anhand der extrahierten Graufstufenbilder mithilfe eines Vertex Shaders entsprechend in der Höhe verschoben. Die Texturierung der Geometrie erfolgt mithilfe des Fragment Shaders und der extrahierten Bilddaten aus dem swissIMAGE Datensatz. 

Bei der Darstellung dieser Geometrien sind jedoch Risse zwischen unterschiedlichen LOD Stufen entstanden. Grund hierfür ist, dass die Punkte an den Kanten der Geometrien nicht zueinander passen und so entsprechende Risse entstehen. Die Lösung dieses Problems war das sogenannte \textit{Index Stitching}, welches auch bei der Frostbite Engine zum Einsatz kommt. Damit das Index Stitching jedoch funktioniert, musste auch sichergestellt werden, dass sich benachbarte Nodes im Quadtree um maximal eine Baumtiefe unterscheiden. Hierzu musste der Quadtree entsprechend ausbalanciert werden. Um die Korrektheit des Quadtrees sowie der Index-Stitching Methode zu verifizieren, wurden ebenfalls entsprechende Hilfsvisualisierungen erstellt.

\section{Ästhetik}
Nebst der eigentlichen Visualisierung spielt auch die Ästhetik eine wichtige Rolle. Die Frage \textbf{``Wie kann die Ästhethik einer 3D Terrainvisualisierung beeinflusst werden?''} umfasst hierbei mehrere Facetten. Mithilfe von \acrshort{HDR} Texturen wurde das Lichtspektrum der einzelnen Farben verbessert. In Kombination mit unterschiedlichen Tone Mapping Verfahren, welche das Lichtspektrum wieder in einen darstellbaren Bereich umwandeln, können so auf einfache Art und Weise verschiedene ästhetische Variationen der Visualisierung erstellt werden.

Während sich der Nutzer mithilfe der implementierten Steuerungselemente durch den 3D Raum fortbewegt, können je nach Neigung und Blickwinkel verwaschene Texturen in der Ferne entstehen. Um diese Problem zu lösen, wurde das Anisotropic Filtering von Three.js verwendet. Um das Gefühl zu vermitteln, dass sich die Visualisierung in einer wirklichen Welt befindet, wurde auch ein entsprechender Himmel mit Sonnenstand sowie Tag- und Nachtzyklus umgesetzt. Hierzu konnte auf das breite Ökosystem von Three.js zurückgegriffen werden.

Damit die Auswirkungen der oben beschriebenen Verfahren in Echtzeit observiert werden können, sind entsprechende Controls (Tweaks) zur Veränderung diverser Parameter implementiert worden. Diese Tweaks erlauben es, verschiedene Kombinationen von Einstellungsmöglichkeiten direkt in der Visualisierung selbst auszuprobieren und somit ein ästhetisch stimmendes Bild für den Betrachter zu schaffen.

\section{Optimierungen}
Im Zentrum der Optimierung steht die Forschungsfrage \textbf{``Welche Optimierungen sind notwendig, um die Echtzeitfähigkeit der Visualisierung zu gewährleisten?''}. Um diese Frage zu beantworten, musste in einem ersten Schritt die eigentliche Performanz gemessen werden. Für die Messung wurden die Regionen Chur und Sargans verwendet. Die Messung erfolgte hierbei auf einem Macbook Pro M3 Max, welches an einem Monitor mit einer Auflösung von 5120 auf 2880 Pixel angeschlossen war. Mithilfe der Bibliothek \textit{stats-gl} konnten wichtige Metriken wie Bildwiederholrate sowie CPU und GPU Auslastung in Echtzeit mithilfe von Grafen visualisiert werden. Hier hat sich gezeigt, dass die Terrainvisualisierung das vordefinierte Ziel von 60 Bildern in der Sekunde erfüllen kann. Um dieses Ziel zu erreichen, wurden einige Optimierungen im Vorfeld vorgenommen. Da der Quadtree Algorithmus rund 60 Mal pro Sekunde ausgeführt werden muss und je nach Region und Baumtiefe eine gewisse Komplexität besitzt, hat der Autor entschieden, diesen mithilfe eines Webworkers in einen separaten Thread auszulagern. Um zudem keine Verzögerungen beim dynamischen Laden von Bildern zu verursachen, werden die Bilder beim Start der Visualisierung vorgeladen.

Während sich der Nutzer durch das Gebirge bewegte, konnten jedoch trotzdem kleine Unterbrechungen registriert werden. Mithilfe der integrierten Browser Monitoring Tools konnten hierzu zwei primäre Probleme identifiziert werden. Das erste Problem bestand in der Übersetzung von der Three.js spezifischen Shadersprache TSL nach GLSL/WGSL. Die Transpilation lief hierbei auf dem CPU ab und benötigte entsprechend Zeit. Die Lösung dieses Problems bestand darin, auf das robustere WebGL Backend von Three.js zu wechseln und die Shader direkt in der nativen Sprache (GLSL) zu schreiben. Somit konnte der Übersetzungsschritt von TSL zu GLSL komplett eliminiert werden. Eine weitere Problematik hat sich beim Dekodieren der Bilddateien gezeigt. Damit die Bilder von der Grafikkarte entsprechend verarbeitet werden können, müssen diese zuerst dekodiert und vom CPU an die GPU gesendet werden. Dieser Dekodierungsschritt hat ebenfalls zu den kleinen Verzögerungen beigetragen. Um das Dekodierungsproblem zu lösen, wurden die Bilder in das KTX2 umgewandelt. Das KTX2 Format hat hierbei den Vorteil, dass die Bilder nicht dekodiert werden müssen, sondern direkt an die Grafikkarte gesendet werden können. Mithilfe dieser Optimierungen konnten die Unterbrechungen beseitigt werden.