\chapter{Diskussion}
\label{chap_diskussion}
Dieses Kapitel fasst die wichtigsten Aspekte und Erkenntnisse zusammen und thematisiert diese anhand der in Kapitel \ref{chap_einleitung} definierten Forschungsfragen. Ziel ist es, eine konstruktive Diskussion zu führen, bei welcher auch die Entscheidungen reflektiert werden.

\section{Wahl der Technologie}
Für die Entwicklung einer echtzeitfähigen 3D-Datenvisualisierung ist die Wahl der zugrundeliegenden Technologie entscheidend. Um die Frage \textbf{``Welche Technologie ist für eine echtzeitfähige 3D Datenvisualisierung geeignet?''}, zu beantworten, wurde der Fokus dieser Arbeit primär auf Spiele Engines sowie Frameworks gelegt. Ein wesentlicher Vorteil von Spiele-Engines gegenüber Frameworks besteht darin, dass sie integrierte Editoren zur Erstellung von 3D-Visualisierungen bereitstellen. Darüber hinaus bieten sie in der Regel ein umfangreicheres Funktionsspektrum sowie eine breitere Plattformunterstützung.

Demgegenüber bringen proprietäre Engines wie Unity oder Unreal auch Einschränkungen mit sich. So fallen je nach Lizenzmodell zusätzliche Kosten an, und bei technischen Problemen ist man auf den Support der jeweiligen Hersteller angewiesen. Zudem ist der Quellcode nicht frei zugänglich, wodurch eigene Anpassungen oder Fehlerbehebungen nur eingeschränkt möglich sind. Abhängig von der gewählten Engine ist ausserdem ein nicht unerheblicher Lernaufwand sowie leistungsfähige Hardware erforderlich.

Frameworks sind aufgrund des reduzierten Funktionsumfangs platzsparender und ressourcenschonender als Engines. Frameworks bieten Funktionalitäten in Form von wiederverwendbaren Bausteinen (Modulen) an. Es ist die Aufgabe des Programmierers, diese zu einer funktionierenden Gesamtlösung zu vereinen. Je nach Anwendungsfall, Wissensstand und Komplexität sind Frameworks besser geeignet als grosse komplexe Engines. Wichtige Voraussetzungen sind eine gute Dokumentation sowie entsprechende Anwendungsbeispiele. Im Verlauf dieser Arbeit hat sich gezeigt, dass das Three.js-Framework eine geeignete Wahl für die Umsetzung der Terrainvisualisierung darstellt. Zwar mussten zahlreiche Komponenten eigenständig implementiert werden, dadurch konnte jedoch eine Lösung entwickelt werden, die gezielt auf die vorliegende Problemstellung zugeschnitten ist. Bei auftretenden Problemen erwiesen sich die umfangreiche Dokumentation, eine aktive Community sowie zahlreiche Anwendungsbeispiele als wertvolle Unterstützung. 

\section{Datenvorverarbeitung}
Wie bei einem Gebäudebau als Erstes ein stabiles Fundament errichtet werden muss, ist bei der Datenvisualisierung eine saubere Datenvorverarbeitung von entscheidender Bedeutung. Um die Forschungsfrage \textbf{``Welche Probleme treten bei der Datenvorverarbeitung auf?''} adäquat zu beantworten, werden die wichtigsten Schritte und Erkenntnisse der Datenvorverarbeitung nochmals zusammengefasst und thematisiert.

Als Datengrundlage werden die beiden Datensätze swissALTI3D und swissIMAGE von swisstopo verwendet. swissALTI3D stellt das digitale Höhenmodell bereit, während swissIMAGE die Luftbilder liefert. Die Kombination beider Datensätze bildet die Grundlage für die Rekonstruktion der 3D-Modelle und damit die Datenbasis der Terrainvisualisierung. Beide Datensätze stellen jeweils 1km auf 1km grosse Kacheln (Tiles) in unterschiedlicher Auflösung basierend auf dem LV-95 Koordinatensystem zur Verfügung. Um die Komplexität zu reduzieren, hat sich der Autor dazu entschlossen, die gleiche Auflösung (2m pro Pixel) für beide Datensätze zu verwenden. 

Zu Beginn mussten die Daten extrahiert werden. Für den swissALTI3D Datensatz wurden die Höhenwerte als Graustufenbild gespeichert. Die einzelnen Höhenwerte werden als Pixel abgespeichert, wobei Weiss hohe und Schwarz niedrige Werte repräsentiert. Um ein Gesamtbild zu erhalten, sind anschliessend die einzelnen Tiles anhand des LV-95 Koordinatensystems zu einem Gesamtbild zusammengesetzt worden. Dabei hat sich gezeigt, dass die Höhenwerte normalisiert werden müssen, da sonst keine fliessenden Übergänge zwischen den einzelnen Tiles existieren.


Die Geodaten können für unterschiedliche Regionen über die Webseite von swisstopo bezogen werden. Der Download erfolgt entweder einzeln oder gesammelt über CSV-Dateien, die die entsprechenden Download-Links enthalten. Um den Downloadprozess zu vereinfachen, wurde dieser mithilfe eines Python-Skripts auf Basis der bereitgestellten CSV-Dateien automatisiert. Die heruntergeladenen Tiles werden anschliessend zu einem Gesamtbild zusammengesetzt. Dabei zeigte sich, dass das resultierende Bild vereinzelt schwarze Bereiche aufweisen kann, die auf fehlende Daten zurückzuführen sind. Da die Tiles auf dem LV95-Koordinatensystem basieren und die Download-URLs einer festen Struktur folgen, konnten diese Datenlücken automatisch identifiziert und geschlossen werden. Da Grafikhardware Texturen mit quadratischer Auflösung effizienter verarbeiten, wurde abschliessend das Gesamtbild auf einen quadratischen Ausschnitt beschränkt.

Anschliessend wurde dieses in mehrere Tiles mit unterschiedlichen Auflösungsstufen (LOD-Level) unterteilt. Die einzelnen LOD-Stufen entsprechen dabei den jeweiligen Nodes der Quadtree-Datenstruktur. Bei der Erzeugung der Tiles in unterschiedlichen Auflösungen zeigte sich jedoch ein weiteres Problem. Zwischen benachbarten Tiles existiert kein Übergangsbereich. Dies führte dazu, dass an den Kanten sichtbare Risse entstehen. Um diesem Effekt entgegenzuwirken, wurden an den Randbereichen die Höhenwerte der jeweils angrenzenden Tiles übernommen.

\section{Umsetzung der Visualisierung}
Die Umsetzung einer echtzeitfähigen Terrainvisualisierung ist mit verschiedenen Herausforderungen verbunden. Um die Frage zu beantworten, \textbf{welche Probleme bei der 3D-Datenvisualisierung von Gebirgslandschaften auftreten}, müssen mehrere Aspekte berücksichtigt werden. Zentrale Voraussetzungen sind dabei eine saubere Datenvorverarbeitung sowie die Wahl eines geeigneten Algorithmus. In dieser Arbeit kommt ein Quadtree-Algorithmus zum Einsatz, der eine effiziente Unterteilung grosser geografischer Gebiete ermöglicht. Der Quadtree wird kontinuierlich in Abhängigkeit von der aktuellen Kameraposition sowie dem Abstand zu den einzelnen Nodes aktualisiert.

Auf Grundlage des Quadtrees und der vorverarbeiteten Daten werden anschliessend die entsprechenden 3D-Modelle erzeugt. Als geometrische Basis dient ein sternförmiges Punktgitter. Die Vertices dieses Gitters werden im Vertex-Shader entsprechend der zugrunde liegenden Höhendaten vertikal verschoben. Die Texturierung der Geometrie erfolgt im Fragment-Shader auf Basis der Luftbilder.

Bei der Darstellung der 3D-Modelle zeigte sich ein weiteres Problem: Treffen Geometrien mit unterschiedlicher Baumtiefe aufeinander, entstehen an den Übergängen sichtbare Risse. Ursache hierfür ist, dass die Vertices entlang der Kanten nicht übereinstimmen und somit keine nahtlose Verbindung entsteht. Zur Lösung dieses Problems wurde die Index-Stitching-Methode eingesetzt. Damit dieses Verfahren korrekt funktioniert, muss sichergestellt werden, dass sich benachbarte Nodes im Quadtree höchstens um eine Baumtiefenstufe unterscheiden. Zu diesem Zweck wurde der Quadtree entsprechend ausbalanciert. Zur Überprüfung der korrekten Funktionsweise des Quadtrees sowie des Index-Stitching-Verfahrens wurden zusätzlich geeignete Hilfsvisualisierungen implementiert.


\section{Ästhetik}
Nebst der eigentlichen Visualisierung spielt auch die Ästhetik eine wichtige Rolle. Die Frage \textbf{``Wie kann die Ästhethik einer 3D Terrainvisualisierung beeinflusst werden?''} umfasst hierbei mehrere Facetten. Dank \acrshort{HDR} Texturen wurde das Lichtspektrum der einzelnen Farben verbessert. In Kombination mit unterschiedlichen Tone Mapping Verfahren konnten so verschiedene ästhetische Variationen der Visualisierung erstellt werden.

Bei der Navigation durch das Terrain können abhängig vom Betrachtungswinkel verwaschene Texturen in der Ferne auftreten. Um diese Problematik zu lösen, wurde das Anisotropic Filtering von Three.js verwendet. Um dein Eindruck zu vermitteln, dass sich die Visualisierung in einer wirklichen Welt befindet, wurde auch ein entsprechender Himmel mit Sonnenstand sowie Tag- und Nachtzyklus umgesetzt. Hierzu konnte auf das breite Ökosystem von Three.js zurückgegriffen werden.

Damit die Auswirkungen der oben beschriebenen Verfahren in Echtzeit observiert werden können, sind entsprechende UI-Elemente (Tweaks) zur Veränderung der Parameter implementiert worden. 

\section{Optimierungen}
Im Zentrum der Optimierung steht die Forschungsfrage \textbf{``Welche Optimierungen sind notwendig, um die Echtzeitfähigkeit der Visualisierung zu gewährleisten?''}. Um diese Frage zu beantworten, musste in einem ersten Schritt die eigentliche Performanz gemessen werden. Für die Messung wurde die Region Chur verwendet. Die Messung erfolgte auf einem Macbook Pro M3 Max, welches an einen Monitor mit einer Auflösung von 5120 auf 2880 Pixel angeschlossen war. Dank der Bibliothek \textit{stats-gl} konnten wichtige Metriken wie Bildwiederholrate sowie CPU- und GPU-Auslastung in Echtzeit mithilfe von Grafen visualisiert werden. Dabei hat sich gezeigt, dass die Terrainvisualisierung das vordefinierte Ziel von 60 Bildern in der Sekunde erfüllt. Hierzu wurden verschiedene Optimierungen vorgenommen. Da der Quadtree-Algorithmus pro Frame ausgeführt wird und mit zunehmender Regionsgrösse an Komplexität gewinnt, wurde dessen Berechnung mittels Webworkern in einen separaten Thread ausgelagert. Um Ladeverzögerungen während der Laufzeit zu vermeiden, werden die Texturen zu Beginn der Visualisierung vorgeladen.

Während der Bewegung durch das Gebirge konnten vereinzelt kurze Unterbrechungen beobachtet werden. Mithilfe der integrierten Browser-Monitoring-Tools wurden dabei zwei Ursachen identifiziert. Eine davon war die Übersetzung von TSL nach GLSL bzw. WGSL. Diese Transpilation erfolgt auf der CPU und erwies sich als zeitintensiv. Die Lösung dieses Problems bestand darin, auf das robustere WebGL Backend von Three.js zu wechseln und die Shader direkt in der nativen Sprache (GLSL) zu schreiben. Somit konnte der Übersetzungsschritt von TSL zu GLSL eliminiert werden. Eine weitere Problematik hat sich beim Dekodieren der Bilddateien gezeigt. Damit die Bilder von der Grafikkarte entsprechend verarbeitet werden können, müssen diese zuerst dekodiert und vom CPU an die GPU gesendet werden. Dieser Dekodierungsschritt hat ebenfalls zu Verzögerungen geführt. Um das Dekodierungsproblem zu lösen, wurden die Bilder in das für Grafikkarten optimierte KTX2-Format umgewandelt. Dieses Format hat den Vorteil, dass die Bilder nicht dekodiert werden müssen und direkt an die Grafikkarte gesendet werden können. Mittels dieser Optimierungen konnten die Unterbrechungen beseitigt werden.