\chapter{Ausblick}
\label{chap_ausblick}
In diesem Kapitel werden der aktuelle Stand der Terrainvisualisierung, bestehende Limitationen sowie mögliche Lösungsansätze und Erweiterungen diskutiert.

\section{Aktueller Stand}
Im Rahmen dieser Arbeit wurde eine webbasierte, echtzeitfähige Terrainvisualisierung auf Basis der swisstopo-Datensätze umgesetzt. Die Grundlage bildet eine weitgehend automatisierte Datenvorverarbeitung. Zur Auswahl der darzustellenden Region ist lediglich der Download der entsprechenden CSV-Datei von der swisstopo-Webseite erforderlich.
Anschliessend werden die benötigten Datensätze automatisch heruntergeladen, vorhandene Datenlücken geschlossen sowie Texturen in unterschiedlichen Auflösungen und Formaten generiert. Während der Laufzeit werden diese Daten mithilfe des Quadtree-Algorithmus in geeignete 3D-Modelle überführt und zu vollständigen Gebirgslandschaften zusammengesetzt.
Bei der Navigation durch das Terrain wird die Detailstufe des Quadtrees kontinuierlich an die aktuelle Position angepasst. Ergänzende UI-Elemente ermöglichen es zudem, das Erscheinungsbild und die ästhetischen Eigenschaften des Terrains in Echtzeit zu verändern.

\section{Limitationen und Lösungsansätze}
Obwohl mithilfe des Quadtree-Algorithmus und gezielter Optimierungen eine echtzeitfähige Terrainvisualisierung auf Basis der swisstopo-Datensätze realisiert werden konnte, bestehen weiterhin einige Limitationen. Eine zentrale Einschränkung der aktuellen Umsetzung ist die Begrenzung auf einen quadratischen Ausschnitt des dargestellten Gebirges. Diese Entscheidung wurde getroffen, um sicherzustellen, dass die erzeugten Texturen ebenfalls quadratische Abmessungen aufweisen, da Grafikhardware solche Texturen besonders effizient verarbeitet. Grundsätzlich sind jedoch sowohl die Quadtree-Datenstruktur als auch moderne Grafikkarten in der Lage, mit nicht quadratischen Texturen umzugehen. Dadurch liesse sich die Visualisierung künftig auf grössere Gebietsformen ausdehnen.

Eine weitere Limitation betrifft die aktuell verwendete Auflösung der Datensätze. In der vorliegenden Umsetzung werden sowohl für den swissALTI3D- als auch für den swissIMAGE-Datensatz einheitlich 2 m pro Bildpunkt verwendet. Dies entspricht für einen Quadratkilometer einer Auflösung von 500 × 500 Pixeln. Beide Datensätze stehen jedoch in zusätzlichen Auflösungsstufen zur Verfügung. Da sie auf dem gleichen LV95-Koordinatensystem basieren, ist es grundsätzlich möglich, unterschiedliche Auflösungen für Höhen- und Bilddaten zu kombinieren. Dadurch könnten insbesondere die Texturen in höherer Detailtiefe dargestellt werden. Dies ist vor allem für CAVE-Systeme mit grossflächigen Projektionswänden von Bedeutung, bei denen hohe Bildauflösungen entscheidend zur Immersion beitragen. Gleichzeitig müsste je nach Einsatzszenario der Umfang der zu verarbeitenden Daten sorgfältig abgewogen werden. Während für CAVE-Systeme grössere Datenmengen vertretbar sind, sollten bei webbasierten Anwendungen aufgrund der Ladezeiten niedrigere Auflösungen und damit kleinere Datensätze bevorzugt werden.

Eine zusätzliche Limitation zeigt sich während der Navigation durch das Gebirge in Form des sogenannten ``Pop-in-Effekts''. Dieser kann als störend wahrgenommen werden, insbesondere wenn neue Geometrien in unmittelbarer Nähe der Nutzer erzeugt werden. Ein möglicher Lösungsansatz stellt das sogenannte ``Vertex Morphing'' dar, das auch von Filip Strugar im Zusammenhang mit dem CDLOD-Algorithmus beschrieben wird \parencite[S. 7]{strugar_cdlod_2009}. Die Grundidee besteht darin, die Positionen der Vertices zwischen verschiedenen Detailstufen mithilfe eines Morph-Faktors zu interpolieren. Auf diese Weise lassen sich fliessende Übergänge zwischen den einzelnen 3D-Geometrien realisieren. Der Einsatz von Vertex Morphing würde zudem das bisher verwendete Index-Stitching-Verfahren überflüssig machen.

\section{Optimierungspotenzial}
Kapitel \ref{chap_future_optimizations} zeigte Optimierungsmöglichkeiten in Bezug auf das Rendering mithilfe von Techniken wie Instance Rendering auf. Jedoch gibt es noch weitere Optimierungsmöglichkeiten. 

Eine Möglichkeit besteht in der Anwendung von Frustum Culling auf den Quadtree-Algorithmus. In der aktuellen Umsetzung wird das gesamte Gebirge unabhängig vom Sichtfeld der Kamera durch den Quadtree unterteilt. Würde das Sichtfeld der Kamera bereits während der Erzeugung des Quadtrees berücksichtigt, könnten nicht sichtbare Bereiche frühzeitig ausgeschlossen werden. Dadurch liesse sich die Laufzeitkomplexität des Algorithmus weiter reduzieren und die Gesamtleistung der Visualisierung verbessern.

Wie in Kapitel \ref{chap_compute_shader} erläutert, ermöglichen Compute Shader die Ausführung allgemeiner Berechnungen direkt auf der Grafikkarte. Auf dieser Grundlage könnten sowohl das aktuell von Three.js auf der CPU durchgeführte Frustum Culling als auch der Quadtree-Algorithmus vollständig auf die GPU ausgelagert werden. Im Gegensatz zur CPU werden Berechnungen auf der GPU parallel ausgeführt. Insbesondere bei grossflächigen Gebirgslandschaften könnten die notwendigen Berechnungen dadurch deutlich schneller erfolgen. Um den tatsächlichen Einfluss von Compute Shadern auf die Laufzeitkomplexität fundiert zu bewerten, wären jedoch weiterführende Performance-Tests mit unterschiedlich grossen Gebieten erforderlich.

\section{Zukünftige Erweiterungsmöglichkeiten}
Die Terrainvisualisierung wurde als webbasierte Anwendung umgesetzt und ist daher ohne zusätzlichen Installationsaufwand auf einer Vielzahl unterschiedlicher Plattformen lauffähig. Eine besonders interessante Zielplattform stellt dabei ein CAVE-System dar (siehe Kapitel \ref{chap_cave}).

CAVE-Systeme verfügen über deutlich grössere Projektionsflächen als herkömmliche Computermonitore, wodurch der Einsatz hochaufgelöster Texturen besonders wichtig ist. Um dies zu unterstützen, müsste das Python-Skript zur Datenvorverarbeitung erweitert werden, sodass Datensätze mit unterschiedlichen Auflösungen verarbeitet werden können. Darüber hinaus bestehen CAVE-Systeme in der Regel aus mehreren Rechnern, von denen jeder einen separaten Projektionsbereich ansteuert. Um eine konsistente Darstellung zu gewährleisten, muss die Visualisierung zwischen diesen Rechnern synchronisiert werden. Hierfür könnten wichtige Informationen wie Kameraposition und Blickrichtung in Echtzeit über WebSockets zwischen den einzelnen Systemen ausgetauscht werden.

Da die Visualisierung auf dem Three.js-Framework basiert, stehen auch Technologien wie WebXR zur Verfügung. Dadurch wäre eine Umsetzung als \textbf{Virtual-Reality-Anwendung} direkt im Browser möglich. In diesem Fall müssten jedoch zentrale technische Aspekte, insbesondere die derzeit auf Maus- und Tastatureingaben ausgelegte Steuerung, an die Interaktion mit VR-Controllern angepasst werden.

Generell könnten die Steuerungselemente erweitert werden, um eine Vielzahl unterschiedlicher Eingabegeräte zu unterstützen. So würde beispielsweise der Einsatz von 3D-Mäusen eine Navigation im dreidimensionalen Raum vollständig ohne Tastatur und klassische Maus ermöglichen. Zudem erlauben Bibliotheken wie \textit{mediapipe}\footnote{\url{https://github.com/google-ai-edge/mediapipe}} die Echtzeiterkennung von Hand- und Gestenbewegungen. Dadurch liessen sich zusätzliche, natürliche Interaktionsmechanismen in die Visualisierung integrieren.

Eine Erweiterung der Anwendung auf Systeme wie CAVE oder Virtual Reality in Kombination mit unterschiedlichen Interaktions- und Steuerungskonzepten würde sich zudem für Nutzertests im Bereich des Usability Engineering anbieten. Ferner könnten auch die visuelle Ästhetik der Darstellung sowie deren Einfluss auf Wahrnehmung, Orientierung und Nutzererlebnis systematisch untersucht werden.

Derzeit ist die Datenvorverarbeitung zwar durch ein Python-Skript automatisiert, muss jedoch manuell gestartet werden. Eine mögliche Erweiterung besteht darin, diesen Prozess direkt in die Anwendung zu integrieren. So könnte eine Liste verfügbarer Regionen angezeigt werden, aus der eine Auswahl getroffen wird. Anschliessend wird die zugehörige CSV-Datei automatisch heruntergeladen und die Datenvorverarbeitung gestartet. Ebenso liesse sich die webbasierte Anwendung mithilfe von Frameworks wie Electron oder Tauri (siehe Kapitel \ref{chap_electron}) als eigenständige Desktop-Applikation realisieren. Dies hätte den Vorteil, dass die Anwendung auch ohne aktive Internetverbindung genutzt werden könnte.

Ergänzend zu den Datensätzen swissALTI3D und swissIMAGE stellt swisstopo mit swissSURFACE3D\footnote{\url{https://www.swisstopo.admin.ch/de/hoehenmodell-swisssurface3d-raster}} einen weiteren Datensatz bereit, der neben dem digitalen Oberflächenmodell auch Informationen zu Vegetation und Bebauung enthält. Auf Grundlage dieser zusätzlichen Daten könnten die dargestellten Gebirgslandschaften künftig um weitere Elemente wie Wälder oder Siedlungsstrukturen erweitert werden.
Ferner liesse sich die visuelle Darstellung durch den gezielten Einsatz von Shadern weiter verfeinern, etwa zur Simulation von Wolkenformationen oder Gewässern. Solche Erweiterungen könnten sowohl die visuelle Qualität als auch die Immersion der Anwendung deutlich erhöhen.

Die aktuelle Implementierung der Terrainvisualisierung basiert auf dem Quadtree Algorithmus in Kombination mit dem Index-Stitching-Verfahren. Wie bereits in Kapitel \ref{chap_algorithmen} diskutiert, existieren jedoch alternative Verfahren, die für diesen Anwendungsfall ebenfalls geeignet wären. Ein besonders vielversprechender Ansatz ist der \acrfull{CDLOD} Algorithmus von Filip Strugar. Durch den Einsatz von Vertex Morphing in Verbindung mit definierten Übergangsbereichen (Transition Areas) lässt sich der Pop-in-Effekt vermeiden. Gleichzeitig entfällt die Notwendigkeit, die Randbereiche einzelner Geometrien speziell aufzubereiten, wodurch das Index-Stitching nicht mehr erforderlich wäre. Ein weiterer Vorteil dieses Verfahrens besteht darin, dass für alle Terrainsegmente dieselbe Geometrie verwendet werden kann. Dies eröffnet zusätzliche Optimierungsmöglichkeiten, etwa durch den Einsatz von Instance Rendering.