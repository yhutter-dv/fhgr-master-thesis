\chapter{Ausblick}
\label{chap_ausblick}
Im Rahmen dieses Kapitels werden der aktuelle Stand, bestehende Limitationen sowie entsprechende Lösungsansätze der Terrainvisualisierung thematisiert. Ebenso werden weiterführende Optimierungs- sowie Erweiterungsmöglichkeiten für die Zukunft aufgezeigt.


\section{Aktueller Stand}
Während dieser Arbeit wurde eine webbasierte, echtzeitfähige Terrainvisualisierung  auf Basis der swisstopo Datensätze umgesetzt. Die Basis hierzu bildet eine weitestgehend komplett automatisierte Datenvorverarbeitung. Der Nutzer muss lediglich die gewünschte Region auf der offiziellen swisstopo-Webseite auswählen und die entsprechende CSV-Datei herunterladen. Anschliessend werden im Rahmen der Datenvorverarbeitung automatisch die entsprechenden Datensätze heruntergeladen, Lücken geschlossen sowie entsprechende Texturen in unterschiedlichen Auflösungen und Metadaten generiert. Die vorverarbeiteten Daten werden zur Laufzeit anhand der Metadaten sowie einer Quadtree Datenstruktur in entsprechende 3D Geometrien umgewandelt. Diese 3D Geometrien werden anschliessend zu einem Gebirge zusammengesetzt. Der Nutzer hat die Möglichkeit, sich mithilfe von verschiedenen Steuerungselementen durch das Gebirge zu bewegen. Während sich der Nutzer fortbewegt, werden der Quadtree sowie das Terrain abhängig von der Position aktualisiert und entsprechend verfeinert. Entsprechende UI-Elemente erlauben es dem Nutzer, das Aussehen sowie die Ästhetik des Terrains in Echtzeit anzupassen.

\section{Limitationen und Lösungsansätze}
Obwohl mithilfe der Quadtree Datenstruktur sowie entsprechend vorgenommenen Optimierungen eine echtzeitfähige Terrainvisualisierung auf Basis der swisstopo Datensätze umgesetzt werden konnte, bestehen noch gewisse Limitationen. Eine Hauptlimitation ist die Beschränkung auf einen quadratischen Ausschnitt des Gebirges. Diese Entscheidung wurde vom Autor getroffen, um sicherzustellen, dass die in der Datenvorverarbeitung erzeugten Texturen ebenfalls eine quadratische Auflösung besitzen. Der Grund für diese Entscheidung ist der Umstand, dass Grafikkarten prinzipiell Texturen in einer quadratischen Auflösung bevorzugen. Jedoch können sowohl die Quadtree Datenstruktur als auch die Grafikkarte ebenso mit nicht quadratischen Texturen umgehen. Hierdurch könnte das gesamte Gebirge visualisiert werden und wäre nicht auf einen Teilausschnitt limitiert.

Eine weitere Limitierung besteht in der Auflösung der Datensätze. Momentan werden sowohl für den swissALTI3D als auch swissIMAGE Datensatz die gleiche Auflösung von 2 Meter pro Bildpunkt verwendet. Ein Kilometer hat somit eine Auflösung von 500px auf 500px. Jedoch stehen beide Datensätze in weiteren Auflösungen zur Verfügung. Da die Datensätze auf dem LV95-Koordinatensystem basieren, sollte es daher möglich sein, unterschiedliche Auflösungen für die Höhen sowie Bilddaten zu verwenden und höher aufgelöste Gebirgsstrukturen zu erhalten. Dies ist insbesondere für Bildschirme mit hoher Auflösung oder CAVE-Systeme mit entsprechend grossen Projektionsflächen von Relevanz. Jedoch müsste hierbei je nach Einsatzzweck die Grösse der Datenmengen beachtet werden. Auf einer Webseite, wo schnelle Ladezeiten eine wichtige Rolle spielen, sollten kleinere Auflösungen und somit kleinere Datensätze präferiert werden. Im Rahmen eines CAVE-Systems ist jedoch eine längere Startphase für höhere und detailgetreuere Darstellungen eher verkraftbar.

Eine letzte Limitierung, welche auffällt, wenn sich der Nutzer durch das Gebirge fortbewegt, ist das plötzliche Erscheinen neuer Geometrien. Dieser Effekt, auch bekannt unter dem Begriff ``Pop-in-Effekt'' kann störend wirken, primär dann, wenn neue Geometrien in der unmittelbaren Nähe des Betrachters erzeugt werden und aus dem Nichts erscheinen. Ein Lösungsansatz hierzu ist das sogenannte ``Vertex Morphing'', welches auch Filip Strugar in seinem Paper verwendet \parencite[S. 7]{strugar_cdlod_2009}. Die Idee hinter dem Vertex Morphing ist es, die einzelnen Punkte zwischen verschiedenen Geometrien anhand eines Morph Faktors zu interpolieren. Hiermit kann ein fliessender Übergang zwischen den 3D Geometrien erreicht werden. Für die Terrainvisualisierung könnte beispielsweise zwischen Geometrien unter LOD-Stufen interpoliert werden. Als Morph Faktor für die Interpolation kann die gleiche Metrik wie beim Quadtree verwendet werden, sprich der Abstand von der Kamera zum Mittelpunkt der einzelnen Geometrien. 

\section{Optimierungspotenzial}
Kapitel \ref{chap_future_optimizations} zeigte Optimierungsmöglichkeiten in Bezug auf das 3D Rendering mithilfe von Techniken wie Instance Rendering auf. Darüber hinaus gibt es jedoch noch weiteres Optimierungspotenzial.  

Eine Optimierungsmöglichkeit besteht in der Nutzung von Frustum Culling für den Quadtree Algorithmus selbst. Momentan wird das komplette Gebirge mithilfe des Quadtree Algorithmus unterteilt. Jedoch könnte bereits während der Generierung des Quadtrees das Sichtfeld der Kamera berücksichtigt und somit die Laufzeitkomplexität des Algorithmus weiter reduziert werden.

Wie in Kapitel \ref{chap_compute_shader} angesprochen sind Compute Shader eine Möglichkeit, um generelle Berechnungen auf der Grafikkarte auszuführen. Hierdurch könnte beispielsweise sowohl das Frustum Culling, welches von Three.js auf der CPU ausgeführt wird, als auch der Quadtree Algorithmus komplett auf die Grafikkarte ausgelagert werden. Anders als die CPU wird die Arbeit auf der GPU hierbei parallel ausgeführt. Bei grossen Gebirgen sollten die notwendigen Berechnungen daher um Faktoren schneller erledigt werden können. Um die Auswirkungen von Compute Shader auf die Laufzeitkomplexität zu erfassen, müssten jedoch auch entsprechende Tests mit unterschiedlichsten Gebirgsgrössen durchgeführt werden.

\section{Zukünftige Erweiterungsmöglichkeiten}
Die Terrainvisualisierung wurde als webbasierte Lösung entwickelt und ist daher ohne Installationsaufwand auf einer Vielzahl von unterschiedlichen Plattformen lauffähig. Eine mögliche Zielplattform ist ein \textbf{CAVE-System} (siehe Kapitel \ref{chap_cave}).

CAVE-Systeme haben grössere Projektionsflächen als herkömmliche Computermonitore. Deshalb ist es wichtig, entsprechend hochaufgelöste Texturen zu verwenden. Hierzu müsste das Python-Script für die Datenvorverarbeitung entsprechend angepasst werden, sodass Datensätze mit einer unterschiedlichen Auflösung verarbeitet werden können. Nebst grösseren Auflösungen besitzen CAVE-Systeme in der Regel auch mehrere Computer. Jeder Computer projiziert hierbei die Visualisierung auf eine separate Projektionsfläche. Deshalb ist es wichtig, die Visualisierung zwischen den verschiedenen Computern synchron zu halten. Hierzu könnten die notwendigen Informationen wie Kameraposition, Blickwinkel und Rotation mithilfe von Websockets zwischen den Rechnern in Echtzeit ausgetauscht werden.

Da die Visualisierung mithilfe des Frameworks Three.js implementiert wurde, stehen auch Technologien wie Web-VR zur Verfügung. Hiermit wäre auch eine Umsetzung als \textbf{Virtual Reality Anwendung} im Browser möglich. Selbstverständlich müssten dann jedoch auch technische Aspekte wie Steuerungselemente, welche momentan mittels Maus und Tastatur funktionieren, überarbeitet werden.

Generell könnten die Steuerungselemente erweitert werden, sodass eine Vielzahl von unterschiedlichen Eingabegeräten unterstützt wird. Mithilfe von 3D-Mäusen wäre etwa die Fortbewegung im dreidimensionalen Raum komplett ohne Tastatur und herkömmlicher Maus umsetzbar. Durch Bibliotheken wie mediapipe\footnote{\url{https://github.com/google-ai-edge/mediapipe}} ist auch die Erkennung von Handgestenbewegungen in Echtzeit möglich. Hierdurch würden sich auch weitere Eingabemöglichkeiten ergeben.

Die Ausweitung auf Systeme wie CAVE oder VR in Kombination mit verschiedenen Interaktionsmöglichkeiten und Steuerungselementen würde sich auch für einen Nutzertest im Bereich Usability Engineering eignen. Hierbei könnten nebst den eigentlichen Interaktionselementen auch die Ästhetik und deren Auswirkungen untersucht werden.

Momentan ist zwar die Datenvorverarbeitung mithilfe eines Python-Skripts automatisiert, jedoch muss dieses vom Nutzer entsprechend ausgeführt werden. Eine Erweiterung in diesem Bereich ist das Integrieren der Datenvorverarbeitung in die Anwendung selbst. Dem Nutzer könnte hierzu in der Anwendung selbst eine Liste mit Regionen angezeigt werden. Nach der Auswahl einer Region wird automatisch die entsprechende CSV-Datei heruntergeladen und die Datenvorverarbeitung gestartet. Mithilfe von Frameworks wie Electron und Tauri (siehe Kapitel \ref{chap_electron}) könnte zudem die webbasierte Anwendung als eigenständige Applikation direkt auf dem Rechner des Nutzers umgesetzt werden. Dies hätte den Vorteil, dass die Anwendung auch offline ausgeführt werden könnte.

Nebst den Datensätzen swissALTI3D und swissIMAGE bietet swisstopo auch einen swissSURFACE3D Datensatz\footnote{\url{https://www.swisstopo.admin.ch/de/hoehenmodell-swisssurface3d-raster}} an. Dieser Datensatz beinhaltet wie swissALTI3D ebenfalls ein digitales Oberflächenmodell jedoch werden hierbei auch Boden, Bewuchs, Wälder, Hochbauten und weitere Kunstbauten einbezogen \parencite{swissSURFACE3D_2024}. Mithilfe dieser Informationen könnten die Gebirge mit weiteren Objekten wie Wäldern und Bebauungen erweitert werden. Mithilfe von Shadern könnten hierzu noch entsprechende Wolkengebilde und Seen generiert werden, was wiederum die Ästhetik der Anwendung verbessert.
