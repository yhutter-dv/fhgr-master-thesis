\chapter{Ausblick}
\label{chap_ausblick}
Im Rahmen dieses Kapitels werden der aktuelle Stand, bestehende Limitationen sowie entsprechende Lösungsansätze und Erweiterungsmöglichkeiten der Terrainvisualisierung thematisiert. 

\section{Aktueller Stand}
Im Rahmen dieser Arbeit wurde eine webbasierte, echtzeitfähige Terrainvisualisierung auf Basis der swisstopo-Datensätze umgesetzt. Grundlage hierfür ist eine weitgehend automatisierte Datenvorverarbeitung. Für die Auswahl der darzustellenden Region ist lediglich der Download der entsprechenden CSV-Datei von der swisstopo-Webseite erforderlich. Anschliessend werden die erforderlichen Datensätze automatisch heruntergeladen, vorhandene Datenlücken geschlossen sowie Texturen in unterschiedlichen Auflösungen und Formaten erzeugt. Zur Laufzeit werden diese Daten auf Basis des Quadtree-Algorithmus in entsprechende 3D-Modelle und schliesslich in vollständige Gebirgslandschaften überführt. Während der Navigation durch das Gebirge werden der Quadtree und das Terrain abhängig von der aktuellen Position kontinuierlich verfeinert. Ergänzende UI-Elemente ermöglichen es, das Erscheinungsbild und die ästhetischen Eigenschaften des Terrains in Echtzeit anzupassen.

\section{Limitationen und Lösungsansätze}
Obwohl mittels des Quadtree Algorithmus sowie entsprechend vorgenommenen Optimierungen eine echtzeitfähige Terrainvisualisierung auf Basis der swisstopo Datensätze umgesetzt werden konnte, bestehen noch gewisse Limitationen. Eine zentrale Limitation der aktuellen Umsetzung ist die Beschränkung auf einen quadratischen Ausschnitt des Gebirges. Diese Einschränkung wurde gewählt, um sicherzustellen, dass die erzeugten Texturen ebenfalls eine quadratische Auflösung besitzen, da Grafikhardware solche Texturen besonders effizient verarbeitet. Grundsätzlich können jedoch sowohl die Quadtree-Datenstruktur als auch moderne Grafikkarten mit nicht quadratischen Texturen umgehen. Hierdurch könnten weitere Teile des Gebirges visualisiert werden.

Eine weitere Limitierung besteht in der Auflösung der Datensätze. Momentan werden sowohl für den swissALTI3D als auch swissIMAGE Datensatz die gleiche Auflösung von jeweils 2m pro Bildpunkt verwendet. Ein Kilometer hat somit eine Auflösung von 500px auf 500px. Jedoch stehen beide Datensätze in weiteren Auflösungen zur Verfügung. Da die Datensätze auf dem gleichen LV95-Koordinatensystem basieren, ist es möglich, unterschiedliche Auflösungen für Datensätze zu verwenden. Hiermit wären höhere Auflösungen in den Bilddateien möglich. Dies ist insbesondere für CAVE-Systeme mit entsprechend grossen Projektionsflächen von Relevanz. Hierzu müsste je nach Einsatzzweck die Grösse der Datenmengen berücksichtigt werden. Auf Webseiten, wo schnelle Ladezeiten eine wichtige Rolle spielen, sollten kleinere Auflösungen und somit kleinere Datensätze präferiert werden. 

Eine weitere Limitation zeigt sich während der Bewegung durch das Gebirge in Form des sogenannten ``Pop-in-Effekts''. Dieser kann störend wirken, primär dann, wenn neue Geometrien in der unmittelbaren Nähe des Betrachters erzeugt werden und aus dem ``Nichts'' erscheinen. Ein Lösungsansatz hierzu ist das sogenannte ``Vertex Morphing'', welches auch Filip Strugar in seinem Paper zu CDLOD verwendet \parencite[S. 7]{strugar_cdlod_2009}. Die Idee hinter dem Vertex Morphing ist es, die einzelnen Punkte zwischen verschiedenen Geometrien anhand eines Morph Faktors zu interpolieren. Hiermit kann ein fliessender Übergang zwischen den 3D Geometrien erreicht werden. Die Verwendung von Vertex Morphing würde auch das Index Stitching Verfahren überflüssig machen. 

\section{Optimierungspotenzial}
Kapitel \ref{chap_future_optimizations} zeigte Optimierungsmöglichkeiten in Bezug auf das Rendering mithilfe von Techniken wie Instance Rendering auf. Jedoch gibt es noch weitere Optimierungsmöglichkeiten. 

Eine Optimierungsmöglichkeit besteht in der Nutzung von Frustum Culling für den Quadtree Algorithmus selbst. Momentan wird das komplette Gebirge mithilfe des Quadtree Algorithmus unterteilt. Jedoch könnte bereits während der Erstellung des Quadtrees das Sichtfeld der Kamera berücksichtigt und somit die Laufzeitkomplexität des Algorithmus weiter reduziert werden.

Wie in Kapitel \ref{chap_compute_shader} angesprochen sind Compute Shader eine Möglichkeit, um generelle Berechnungen auf der Grafikkarte auszuführen. Hierdurch könnten sowohl das Frustum Culling, welches von Three.js auf der CPU ausgeführt wird, als auch der Quadtree Algorithmus komplett auf die Grafikkarte ausgelagert werden. Anders als die CPU wird die Arbeit auf der GPU hierbei parallel ausgeführt. Bei grossen Gebirgen sollten die notwendigen Berechnungen daher um Faktoren schneller erledigt werden können. Um die Auswirkungen von Compute Shader auf die Laufzeitkomplexität zu erfassen, müssten jedoch auch entsprechende Tests mit unterschiedlichsten Gebirgsgrössen durchgeführt werden.

\section{Zukünftige Erweiterungsmöglichkeiten}
Die Terrainvisualisierung wurde als webbasierte Lösung entwickelt und ist daher ohne Installationsaufwand auf einer Vielzahl von unterschiedlichen Plattformen lauffähig. Eine interessante Zielplattform ist ein \textbf{CAVE-System} (siehe Kapitel \ref{chap_cave}).

CAVE-Systeme haben grössere Projektionsflächen als herkömmliche Computermonitore. Deshalb ist es wichtig, entsprechend hochaufgelöste Texturen zu verwenden. Um dies zu ermöglichen, müsste das Python-Script für die Datenvorverarbeitung entsprechend angepasst werden, sodass Datensätze mit einer unterschiedlichen Auflösung verarbeitet werden können. Nebst grösseren Auflösungen besitzen CAVE-Systeme in der Regel auch mehrere Computer. Jeder Computer projiziert hierbei die Visualisierung auf eine separate Projektionsfläche. Deshalb ist es wichtig, die Visualisierung zwischen den verschiedenen Computern synchron zu halten. Hierfür könnten die notwendigen Informationen wie Kameraposition, Blickwinkel und Rotation mittels Websockets zwischen den Rechnern in Echtzeit ausgetauscht werden.

Da die Visualisierung auf Basis des Three.js Frameworks implementiert wurde, stehen auch Technologien wie Web-VR zur Verfügung. Hierdurch wäre auch eine Umsetzung als \textbf{Virtual Reality Anwendung} im Browser möglich. Selbstverständlich müssten dann jedoch auch technische Aspekte wie Steuerungselemente, welche momentan mittels Maus und Tastatur funktionieren, überarbeitet werden.

Generell könnten die Steuerungselemente erweitert werden, sodass eine Vielzahl von unterschiedlichen Eingabegeräten unterstützt wird. Mittels 3D-Mäusen wäre etwa die Fortbewegung im dreidimensionalen Raum komplett ohne Tastatur und herkömmlicher Maus umsetzbar. Durch Bibliotheken wie mediapipe\footnote{\url{https://github.com/google-ai-edge/mediapipe}} ist auch die Erkennung von Handgestenbewegungen in Echtzeit möglich. Hiermit würden sich auch weitere Interaktionsmechanismen ergeben.

Die Ausweitung auf Systeme wie CAVE oder VR in Kombination mit verschiedenen Interaktionsmöglichkeiten und Steuerungselementen würde sich auch für einen Nutzertest im Bereich Usability Engineering eignen. Des Weiteren könnten auch die Ästhetik und deren Auswirkungen untersucht werden.

Aktuell ist die Datenvorverarbeitung durch ein Python-Skript automatisiert, muss jedoch manuell gestartet werden. Eine mögliche Erweiterung besteht darin, die Datenvorverarbeitung direkt in die Anwendung zu integrieren. Hierzu könnte eine Liste mit vorhandenen Regionen angezeigt werden. Nach der Auswahl einer Region wird automatisch die entsprechende CSV-Datei heruntergeladen und die Datenvorverarbeitung gestartet. Mittels Frameworks wie Electron und Tauri (siehe Kapitel \ref{chap_electron}) könnte zudem die webbasierte Anwendung als eigenständige Applikation direkt auf dem Rechner der Zielgruppe umgesetzt werden. Dies hätte den Vorteil, dass die Anwendung auch offline ausgeführt werden könnte.


Zusätzlich zu swissALTI3D und swissIMAGE bietet swisstopo mit swissSURFACE3D\footnote{\url{https://www.swisstopo.admin.ch/de/hoehenmodell-swisssurface3d-raster}} einen Datensatz, der neben dem Oberflächenmodell auch Vegetation und Bebauung umfasst. Auf Basis dieser zusätzlichen Informationen könnten die dargestellten Gebirgslandschaften künftig um weitere Objekte, etwa Wälder oder Bebauungen, erweitert werden. Ergänzend wäre es möglich, mithilfe von Shadern visuelle Effekte wie Wolkenformationen oder Gewässer zu erzeugen, wodurch die visuelle Qualität und Immersion der Anwendung weiter gesteigert werden könnten.

Die aktuelle Implementierung der Terrainvisualisierung basiert auf dem Quadtree Algorithmus in Kombination mit einer Index-Stitching Methode. Jedoch gibt es, wie bereits in Kapitel \ref{chap_algorithmen} thematisiert, noch andere Algorithmen, welche eingesetzt werden könnten. Interessant wäre der \acrfull{CDLOD} Algorithmus von Filip Strugar. Durch den Einsatz von Vertex Morphing in Kombination mit Transition Areas kann der Pop-in-Effekt wirksam reduziert werden. Gleichzeitig entfällt die Notwendigkeit, die Randbereiche einzelner Geometrien speziell aufzubereiten, wodurch der Index-Stitching-Ansatz nicht mehr erforderlich ist. Ein weiterer Vorteil dieses Verfahrens besteht darin, dass für alle Terrainsegmente dieselbe Geometrie verwendet werden kann. Dadurch werden zusätzliche Optimierungen, wie etwa Instance Rendering, ermöglicht.
