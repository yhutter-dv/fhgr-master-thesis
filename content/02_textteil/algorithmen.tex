\chapter{Algorithmen}
\label{chap_algorithmen}
Nachdem ein grundlegendes Verständnis der Datengrundlage, der verfügbaren Frameworks und Engines sowie der Funktionsweise von Render Pipelines geschaffen wurde, widmet sich dieses Kapitel den Algorithmen zur 3D-Terrainvisualisierung.

\section{Quadtree}
In der Terrainvisualisierung wird der Quadtree-Algorithmus aufgrund seiner \textbf{effizienten räumlichen Unterteilung} häufig eingesetzt. Ein Quadtree ist eine baumartige Datenstruktur, die aus Knoten, sogenannten ``Nodes'' besteht. Jeder dieser Knoten besitzt genau vier Kindknoten, wodurch sich der Raum rekursiv in immer kleinere Teilbereiche unterteilen lässt. Der Algorithmus ist vielseitig einsetzbar. Zusätzlich zur effizienten Raumstrukturierung kann er beispielsweise dazu verwendet werden, zu bestimmen, in welchen Bereichen sich bestimmte Objekte befinden (siehe Abbildung \ref{fig_quadtree}). Ebenso eignet sich ein Quadtree als Grundlage für ein \acrfull{LOD}-System. Die zentrale Idee eines solchen Systems besteht darin, dass sich hochauflösende, detailreiche Geometrien in unmittelbarer Nähe befinden, während in grösserer Entfernung weniger detaillierte Geometrien dargestellt werden. Bezogen auf Abbildung \ref{fig_quadtree} lässt sich ein Gebirge mithilfe des Quadtree-Algorithmus effizient in einzelne Teilbereiche, sogenannte ``Tiles'', unterteilen.

\begin{figure}[H]
    \caption{Quadtree Datenstruktur \parencite{quadtree_2016}}
    \includegraphics[width=.6\linewidth]{content/00_assets/quadtree.png}
    \label{fig_quadtree}
\end{figure}
Die Erzeugung der einzelnen Nodes erfolgt anhand eines definierten Kriteriums, etwa des euklidischen Abstands zwischen der Betrachtungsposition und dem Nodemittelpunkt. Um eine unnötige Verfeinerung des Quadtree und die damit verbundene Erhöhung der Laufzeitkomplexität zu vermeiden, wird zusätzlich ein Stoppkriterium, wie die maximale Baumtiefe, festgelegt.

\section{Geometry Clipmap}
Im Gegensatz zu Quadtrees basiert der Geometry-Clipmap-Algorithmus nach Hoppe et al. auf dem Konzept ineinander verschachtelter ``Clipmaps'' (siehe Abbildung \ref{fig_geometry_clipmaps}). Diese Clipmaps werden in \textbf{mehreren Auflösungsstufen} erzeugt, wobei sich Clipmaps mit geringerer Auflösung jeweils über einen grösseren räumlichen Bereich erstrecken.

\begin{figure}[H]
    \caption{Geometry Clipmaps \parencite{gpu_gems_geometry_clipmaps_2005}}
    \includegraphics[width=.6\linewidth]{content/00_assets/geometry_clipmaps.png}
    \label{fig_geometry_clipmaps}
\end{figure}

Ein zentrales Merkmal dieses Ansatzes besteht darin, dass sowohl die zugrunde liegende Geometrie als auch die Anzahl der Vertices pro Clipmap \textbf{konstant} bleiben. Im Unterschied zum Quadtree entfällt somit eine fortlaufende Neuberechnung der Geometrie, da diese unabhängig von der Kameraposition nur einmal erstellt wird. Stattdessen bewegen sich die Clipmaps zentriert um die aktuelle Position über die zugrunde liegenden Gebirgsdaten. Die Gebirgsdaten liegen dabei in Form von Heightmaps (Höhendaten) und Texturen vor (siehe Kapitel \ref{chap_render_pipelines}). Verändert sich die Position der Kamera, muss nicht der gesamte dargestellte Bereich neu berechnet werden, sondern lediglich ein \textbf{Teilbereich der Daten}. Wie in Abbildung \ref{fig_geometry_clipmap_update} dargestellt, betrifft dies jeweils nur den rot markierten Bereich, der sich aus der Positionsänderung der Kamera ergibt.

\begin{figure}[H]
    \caption{Geometry Clipmap Update \parencite{gpu_gems_geometry_clipmaps_2005}}
    \includegraphics[width=.6\linewidth]{content/00_assets/geometry_clipmap_update.png}
    \label{fig_geometry_clipmap_update}
\end{figure}

\section{Virtual Textures}
Für eine überzeugende 3D-Terrainvisualisierung sind hochauflösende Texturen erforderlich. Dies ist insbesondere für CAVE-Systemen relevant, da die Visualisierung in hoher Auflösung auf grossflächigen Projektionswänden dargestellt wird. Moderne Grafikkarten können Texturen mit einer Auflösung von bis zu 4K problemlos verarbeiten. Die für grosse Gebirgslandschaften benötigten Texturen übersteigen diese Grösse jedoch deutlich. So weist der swissIMAGE-Datensatz in der höchsten Auflösung von 10 cm pro Pixel für eine Fläche von einem Quadratkilometer bereits eine Auflösung von 10’000 auf 10’000 Bildpunkten auf. Solche Texturen lassen sich nicht in den Videospeicher der Grafikkarte laden. Zur Lösung dieses Problems kann ein Verfahren namens \acrfull{VT} verwendet werden. Dabei werden grosse Bilder, welche nicht in den Videospeicher der Grafikkarte passen, in \textbf{kleinere Teilbilder} zerlegt. Zur Laufzeit wird bestimmt, welche Teilbilder sich im Sichtfeld des Betrachters befinden. Diese werden in eine im Videospeicher vorgehaltene ``virtuelle'' Textur übertragen \parencite{threejs_virtual_texture}. Der rot markierte Bereich in Abbildung  \ref{fig_virtual_textures} beinhaltet die Teilbilder, die in die virtuelle Textur (rechts unten) geladen werden. Dieses Verfahren lässt sich mit weiteren Algorithmen, etwa Geometry Clipmaps, kombinieren, um eine effiziente Darstellung grossflächiger Texturen zu ermöglichen.
\begin{figure}[H]
    \caption{Virtual Texture \parencite{threejs_virtual_texture}}
    \includegraphics[width=.3\linewidth]{content/00_assets/virtual_textures.png}
    \label{fig_virtual_textures}
\end{figure}

\section{Continuous Distance-Dependent Level of Detail}
Ein Hauptproblem, welches bei \acrshort{LOD} basierten Systemen auftritt, sind \textbf{Diskrepanzen zwischen verschiedenen Auflösungen (LOD-Level)}. Treffen Geometrien mit einer unterschiedlichen Auflösung aufeinander, passen die einzelnen Punkte nicht aufeinander und es entstehen Risse (siehe rote Bereiche in Abbildung \ref{fig_lod_tjunctions}). 
\begin{figure}[H]
    \caption{Geometrische Diskrepanzen zwischen verschiedenen LOD Level \parencite{frostbite_terrain_rendering_2007}}
    \includegraphics[width=.3\linewidth]{content/00_assets/lod_tjunctions.png}
    \label{fig_lod_tjunctions}
\end{figure}

\newpage
Der quadtreebasierte \acrfull{CDLOD} Algorithmus nach Filip Strugar adressiert diese Problematik auf elegante Weise. Anstatt Übergänge zwischen unterschiedlichen Detailstufen zu erzeugen, werden für jedes LOD-Level entsprechende Übergangsbereiche, sogenannte ``morph areas'', definiert (siehe Abbildung \ref{fig_cdlod_quadtree}).

\begin{figure}[H]
    \caption{CDLOD Quadtree und Übergangsbereiche \parencite[S. 4]{strugar_cdlod_2009}}
    \includegraphics[width=.8\linewidth]{content/00_assets/cdlod_quadtree_morph.png}
    \label{fig_cdlod_quadtree}
\end{figure}

Innerhalb dieser Bereiche werden die Positionen der Vertices kontinuierlich vom aktuellen zum nächsthöheren LOD-Level \textbf{interpoliert}, sodass die angrenzenden Geometrien nahtlos ineinander übergehen. Diese kontinuierliche Anpassung der Vertex-Positionen wird als ``Vertex Morphing'' bezeichnet. Abbildung \ref{fig_cdlod_vertex_morphing} veranschaulicht, wie sich die Punkte eines Gitternetzes in Abhängigkeit zum Interpolationsfaktor verändern.

\begin{figure}[H]
    \caption{CDLOD - Interpolation der einzelnen Punkte \parencite[S. 8]{strugar_cdlod_2009}}
    \includegraphics[width=.6\linewidth]{content/00_assets/cdlod_vertex_morphing.png}
    \label{fig_cdlod_vertex_morphing}
\end{figure}

Eine Einschränkung dieses Ansatzes besteht darin, dass sich benachbarte LOD-Level nur um eine Detailstufe unterscheiden dürfen. Entsprechend muss auch der zugrunde liegende Quadtree ausbalanciert sein. Durch den Einsatz von Vertex Morphing werden jedoch nicht nur sichtbare Risse zwischen Geometrien vermieden, sondern auch sogenannte ``Pop-in-Effekte''. Diese treten auf, wenn Geometrien abrupt im Sichtfeld erscheinen. Da die Geometrien beim CDLOD-Ansatz kontinuierlich interpoliert werden, treten diese Effekte nicht auf \parencite[S. 3]{strugar_cdlod_2009}.