\chapter{Algorithmen}
\label{chap_algorithmen}
Da nun ein Grundverständnis sowohl über die Datengrundlage, existierende Framworks und Engines, als auch über die Art und Weise, wie Render Pipelines funktionieren, vorhanden ist, werden in diesem Kapitel Algorithmen mit Fokus auf 3D-Terrainvisualisierungen thematisiert. 

\section{Quadtree}
In der Terrainvisualisierung wird der Quadtree Algorithmus aufgrund der effizienten räumlichen Unterteilung häufig angewendet. Ein Quadtree ist eine baumähnliche Datenstruktur, welche aus Knoten (Nodes) besteht. Eine spezielle Eigenschaft dieser Knoten ist es, dass sie genau vier Child Nodes besitzen. Der Algorithmus ist vielseitig einsetzbar. Abgesehen von einer effizienten Raumunterteilung kann auch detektiert werden, in welchen Bereichen sich bestimmte Objekte befinden (siehe Abbildung \ref{fig_quadtree}). Ebenso kann ein Quadtree als Basis für ein \acrfull{LOD}-System genutzt werden.  Die Grundidee bei einem LOD-System ist es, dass kleine, hochauflösende Geometrien sich in unmittelbarer Nähe des Betrachters befinden und grössere, weniger gut aufgelöste Geometrien in der Ferne anzutreffen sind. Bezogen auf Abbildung \ref{fig_quadtree} kann hiermeit ein Gebirge mithilfe des Quadtree Algorithmus auf effiziente Art und Weise in einzelne Kacheln, auch unter dem Begriff ``Tiles'' bekannt, unterteilt werden.
\begin{figure}[H]
    \caption{Quadtree Datenstruktur \parencite{quadtree_2016}}
    \includegraphics[width=.6\linewidth]{content/00_assets/quadtree.png}
    \label{fig_quadtree}
\end{figure}
Die Erstellung der einzelnen Nodes erfolgt anhand eines definierten Kriteriums, beispielsweise des euklidischen Abstands zwischen der Betrachtungsposition und dem Mittelpunkt einer Node. Um eine unnötige Verfeinerung des Quadtree und die damit verbundene Erhöhung der Laufzeitkomplexität zu vermeiden, wird zusätzlich ein Stoppkriterium, etwa die maximale Baumtiefe, festgelegt.

\section{Geometry Clipmap}
Anders als Quadtrees basiert der Geometry Clipmap Algorithmus von Hoppe et. al. auf dem Konzept von ineinander verschachtelten ``Clipmaps'' (siehe Abbildung \ref{fig_geometry_clipmaps}). 
\begin{figure}[H]
    \caption{Geometry Clipmaps \parencite{gpu_gems_geometry_clipmaps_2005}}
    \includegraphics[width=.6\linewidth]{content/00_assets/geometry_clipmaps.png}
    \label{fig_geometry_clipmaps}
\end{figure}
Die Clipmaps werden dabei in verschiedenen ``Auflösungen'' erstellt. Je nach Auflösung erstreckt sich die Clipmap über einen grösseren Bereich. Die eigentliche Geometrie und die Anzahl der Vertices der Climpas sind konstant. Dies bedeutet, dass die Geometrie der Clipmaps nur einmal erstellt werden muss und nicht wie bei einem Quadtree, abhängig von der Kameraposition, jedes Mal neu berechnet wird. Die Clipmaps ``wandern'' zentriert um die Kameraposition über die Gebirgsdaten. Die Gebirgsdaten bestehen aus Heightmaps (Höhendaten) und Texturen (siehe Kapitel \ref{chap_render_pipelines}). Ändert sich die Kameraposition, muss nicht der gesamte Bereich, sondern nur ein Teilausschnitt der Daten neu berechnet werden. Wie in Abbildung \ref{fig_geometry_clipmap_update} zu sehen ist, wird jeweils nur der rote Bereich, welcher sich durch die Veränderung der Kameraposition ergibt, neu berechnet werden.
\begin{figure}[H]
    \caption{Geometry Clipmap Update \parencite{gpu_gems_geometry_clipmaps_2005}}
    \includegraphics[width=.6\linewidth]{content/00_assets/geometry_clipmap_update.png}
    \label{fig_geometry_clipmap_update}
\end{figure}

\section{Virtual Textures}
Für eine überzeugende 3D-Terrainvisualisierungen müssen hochauflösende Texturen verwendet werden. Dies ist besonders in \acrshort{CAVE}-Systemen relevant, da die Visualisierung in einer hohen Auflösung auf entsprechend grosse Wände projiziert wird. Moderne Grafikkarten können Texturen bis zu einer Auflösung von 4k problemlos verarbeiten. Die Texturen für grosse Gebirge sind jedoch um Faktoren grösser. Der swissIMAGE-Datensatz in der höchsten Auflösung von 10cm pro Pixel benötigt für eine Fläche von einem km$^2$ bereits eine Auflösung von 10'000 auf 10'000 Bildpunkten. Ein solches Bild kann nicht ohne Weiteres in den Videospeicher der Grafikkarte geladen werden. Um diese Problematik zu lösen kann ein Verfahren namens \acrfull{VT} verwendet werden. Dabei werden grosse Bilder, welche nicht in den Videospeicher der Grafikkarte passen, in kleinere Teilbilder zerlegt. Zur Laufzeit wird bestimmt, welche Teilbilder sich im Sichtfeld des Betrachters befinden. Diese werden in eine im Videospeicher vorgehaltene ``virtuelle'' Textur übertragen \parencite{threejs_virtual_texture}. Die rot markierten Bereiche in Abbildung  \ref{fig_virtual_textures} verdeutlichen die Teilbilder, die in die virtuelle Textur (rechts unten) geladen werden. Dieses Verfahren lässt sich auch mit weiteren Algorithmen wie Geometry Clipmaps kombinieren.
\begin{figure}[H]
    \caption{Virtual Texture \parencite{threejs_virtual_texture}}
    \includegraphics[width=.3\linewidth]{content/00_assets/virtual_textures.png}
    \label{fig_virtual_textures}
\end{figure}

\section{Continuous Distance-Dependent Level of Detail}
Ein Hauptproblem, welches bei \acrshort{LOD} basierten Systemen auftritt, sind Diskrepanzen zwischen verschiedenen Auflösungen (LOD Level). Treffen Geometrien mit einer unterschiedlichen Auflösung aufeinander, passen die einzelnen Punkte der Dreiecke nicht aufeinander und es entstehen Risse (siehe rote Bereiche in Abbildung \ref{fig_lod_tjunctions}). 
\begin{figure}[H]
    \caption{Geometrische Diskrepanzen zwischen verschiedenen LOD-Level \parencite{frostbite_terrain_rendering_2007}}
    \includegraphics[width=.3\linewidth]{content/00_assets/lod_tjunctions.png}
    \label{fig_lod_tjunctions}
\end{figure}

\newpage
Der Quadtree basierte \acrfull{CDLOD} Algorithmus von Filip Strugar löst diese Problematik mit seinem \acrfull{CDLOD} Algorithmus auf elegante Art und Weise. Für jedes LOD Level werden Übergangsbereiche, sogenannte ``morph areas'', definiert (siehe Abbildung \ref{fig_cdlod_quadtree}). 
\begin{figure}[H]
    \caption{CDLOD Quadtree und Übergangsbereiche \parencite[S. 4]{strugar_cdlod_2009}}
    \includegraphics[width=.8\linewidth]{content/00_assets/cdlod_quadtree_morph.png}
    \label{fig_cdlod_quadtree}
\end{figure}
Innerhalb dieser Übergangsbereiche werden die Positionen der Vertices vom aktuellen zum nächsten LOD Level interpoliert und passen somit perfekt aufeinander. Die Interpolation von Punkten einer Geometrie wird auch als ``Vertex Morphing'' bezeichnet. Abbildung \ref{fig_cdlod_vertex_morphing} zeigt, wie sich die Punkte auf einem Gitternetz abhängig vom Interpolationsfaktor verändern. 
\begin{figure}[H]
    \caption{CDLOD - Interpolation der einzelnen Punkte \parencite[S. 8]{strugar_cdlod_2009}}
    \includegraphics[width=.6\linewidth]{content/00_assets/cdlod_vertex_morphing.png}
    \label{fig_cdlod_vertex_morphing}
\end{figure}
Eine Limitierung dieses Algorithmus ist, dass sich LOD Level nur um jeweils eine Stufe unterscheiden dürfen. Dies bedeutet, dass auch der Quadtree entsprechend ausbalanciert sein muss. Mittels Vertex Morphing werden nicht nur Risse, sondern auch sogenannte ``Pop-in-Effekte'' vermieden. Pop-in-Effekte entstehen, wenn Geometrien plötzlich aus dem Nichts vor dem Betrachter auftauchen. Da die verschiedenen Geometrien jedoch abhängig von der Kameraposition und der Distanz zu den Übergangsbereichen interpoliert werden, tritt dieser Effekt nicht auf \parencite[S. 3]{strugar_cdlod_2009}.